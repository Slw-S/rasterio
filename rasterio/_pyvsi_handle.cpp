#include <iostream>
#include <algorithm>

#include "cpl_port.h"
#include "cpl_vsi.h"
#include "cpl_vsi_virtual.h"
#include "Python.h"
#include "_pyvsi_handle.h"
// automatically generated by cython
//#include "rasterio._pyvsi_api.h"
//#include "rasterio._pyvsi.h"

namespace pyvsi_handle {

PythonVSIVirtualHandle::PythonVSIVirtualHandle(PyObject *obj) : open_file_obj(obj) {
    std::cout << "Constructor\n" << std::flush;
    PyGILState_STATE gil_state = PyGILState_Ensure();
    // provided by "_pyvsi_api.h"
//    if (import_rasterio___pyvsi()) {
//    } else {
    Py_XINCREF(this->open_file_obj);
//    }
    PyGILState_Release(gil_state);
}

PythonVSIVirtualHandle::~PythonVSIVirtualHandle() {
    std::cout << "Deconstructor\n" << std::flush;
    PyGILState_STATE gil_state = PyGILState_Ensure();
    Py_XDECREF(this->open_file_obj);
    PyGILState_Release(gil_state);
}

int PythonVSIVirtualHandle::Seek(vsi_l_offset nOffset, int nWhence) {
    std::cout << "Seek: " << nOffset << " : " << nWhence << "\n" << std::flush;
    PyGILState_STATE gil_state = PyGILState_Ensure();
    PyObject* file_obj = PyObject_GetAttrString(this->open_file_obj, "_file_obj");
    PyObject* py_new_loc = PyObject_CallMethod(file_obj, "seek", "(i,i)", nOffset, nWhence);

    if (!PyLong_Check(py_new_loc)) {
        // FIXME: Better error handling?
        std::cout << "Seek: Not a long\n" << std::flush;
        Py_DECREF(file_obj);
        Py_XDECREF(py_new_loc);
        PyGILState_Release(gil_state);
        return -1;
    }

    long loc = PyLong_AsLong(py_new_loc);
    if (loc == -1) {
        // FIXME: Better error handling?
        std::cout << "Seek: Can't convert to long\n" << std::flush;
        Py_DECREF(file_obj);
        Py_DECREF(py_new_loc);
        PyGILState_Release(gil_state);
        return -1;
    }

    Py_DECREF(file_obj);
    Py_DECREF(py_new_loc);
    PyGILState_Release(gil_state);
    return 0;
}

vsi_l_offset PythonVSIVirtualHandle::Tell() {
    std::cout << "Tell\n" << std::flush;
    PyGILState_STATE gil_state = PyGILState_Ensure();
    PyObject* file_obj = PyObject_GetAttrString(this->open_file_obj, "_file_obj");
    PyObject* py_loc = PyObject_CallMethod(file_obj, "tell", nullptr);
    if (!PyLong_Check(py_loc)) {
        // FIXME: Better error handling?
        std::cout << "Tell: Not a long\n" << std::flush;
        Py_DECREF(file_obj);
        Py_XDECREF(file_obj);
        PyGILState_Release(gil_state);
        return 0;
    }

    long loc = PyLong_AsLong(py_loc);
    if (loc == -1) {
        // FIXME: Better error handling?
        std::cout << "Tell: Could not convert to C long\n" << std::flush;
        Py_DECREF(file_obj);
        Py_DECREF(py_loc);
        PyGILState_Release(gil_state);
        return 0;
    }

    Py_DECREF(file_obj);
    Py_DECREF(py_loc);
    PyGILState_Release(gil_state);
    std::cout << "Tell: Success : " << loc << "\n" << std::flush;
    return (vsi_l_offset)loc;
}

size_t PythonVSIVirtualHandle::Read(void *pBuffer, size_t nSize, size_t nCount) {
    std::cout << "Read: " << nSize << " : " << nCount << "\n" << std::flush;
    size_t nBytesToRead = nSize * nCount;

    PyGILState_STATE gil_state = PyGILState_Ensure();
    std::cout << "Before open file obj print\n" << std::flush;
    PyObject_Print(this->open_file_obj, stdout, 0);
    std::cout << "After open file obj print\n" << std::flush;
    PyObject* file_obj = PyObject_GetAttrString(this->open_file_obj, "_file_obj");
    if (file_obj == NULL) {
        std::cout << "File object is NULL\n" << std::flush;
    }
    PyObject_Print(file_obj, stdout, 0);
    std::cout << std::flush;
    if (PyObject_HasAttrString(file_obj, "read") == 0) {
        std::cout << "File object does not have read method\n" << std::flush;
    }
    std::cout << "Read: After object\n" << std::flush;
    // TODO: Check for null
    // TODO: Do we need to decrement ref counter for read_results?
    PyObject* read_results = PyObject_CallMethod(file_obj, "read", "(n)", nBytesToRead);
    std::cout << "Read: After call\n" << std::flush;
    // TODO: Handle unicode? Will that ever happen?
    Py_ssize_t num_read_bytes = PyBytes_Size(read_results);
    std::cout << "Read: After size: " << num_read_bytes << "\n" << std::flush;
    char *read_array = PyBytes_AsString(read_results);
    std::cout << "Read: After as string\n" << std::flush;
//    strncpy((char *)pBuffer, read_array, num_read_bytes);
    memcpy(pBuffer, (void *)read_array, static_cast<size_t>(num_read_bytes));
    std::cout << "Read: After string copy\n" << std::flush;
    Py_DECREF(file_obj);
    Py_DECREF(read_results);
    PyGILState_Release(gil_state);
    // FIXME: This is technically supposed to be "number of objects" but nSize is always 1 (so far)
    return num_read_bytes;
}

int PythonVSIVirtualHandle::ReadMultiRange(int nRanges, void ** ppData,
                              const vsi_l_offset* panOffsets,
                              const size_t* panSizes) {

    std::cout << "ReadMultiRange\n" << std::flush;
    return 0;
}

size_t PythonVSIVirtualHandle::Write(const void *pBuffer, size_t nSize, size_t nCount) {
    std::cout << "Write\n" << std::flush;
    return 0;
}

int PythonVSIVirtualHandle::Eof() {
    std::cout << "Eof\n" << std::flush;
    return 0;
}

//int PythonVSIVirtualHandle::Flush() {
//    return 0;
//}

int PythonVSIVirtualHandle::Close() {
    std::cout << "Close\n" << std::flush;
    return 0;
}

// Base implementation that only supports file extension.
int PythonVSIVirtualHandle::Truncate(vsi_l_offset nNewSize) {
    std::cout << "Truncate\n" << std::flush;
    return 0;
}

//void *PythonVSIVirtualHandle::GetNativeFileDescriptor() {
//    return nullptr;
//}

//VSIRangeStatus PythonVSIVirtualHandle::GetRangeStatus(
//                CPL_UNUSED vsi_l_offset nOffset,
//                CPL_UNUSED vsi_l_offset nLength ) {
//    return VSI_RANGE_STATUS_UNKNOWN;
//}

class VSIPythonFileLikeFilesystemHandler final : public VSIFilesystemHandler
{
    CPL_DISALLOW_COPY_ASSIGN(VSIPythonFileLikeFilesystemHandler)

  public:
    std::map<CPLString, PythonVSIVirtualHandle*> oFileList{};
//    std::map<CPLString, VSIPythonFileLike*> oFileList{};
    CPLMutex        *hMutex = nullptr;

    VSIPythonFileLikeFilesystemHandler() = default;
    ~VSIPythonFileLikeFilesystemHandler() override;

    using VSIFilesystemHandler::Open;

//    VSIVirtualHandle *Open( const char *pszFilename,
//                            const char *pszAccess,
//                            bool bSetError,
//                            CSLConstList papszOptions ) override { return nullptr; };
    VSIVirtualHandle *Open( const char *pszFilename,
                            const char *pszAccess,
                            bool bSetError ) override;
    int Stat( const char *pszFilename, VSIStatBufL *pStatBuf,
              int nFlags ) override;
    int Unlink( const char *pszFilename ) override;
    int Mkdir( const char *pszDirname, long nMode ) override;
    int Rmdir( const char *pszDirname ) override;
    char **ReadDirEx( const char *pszDirname,
                      int nMaxFiles ) override;
    int Rename( const char *oldpath,
                const char *newpath ) override;
    GIntBig  GetDiskFreeSpace( const char* pszDirname ) override;

    static std::string NormalizePath( const std::string &in );

    int              Unlink_unlocked( const char *pszFilename );
};

void VSIInstallPythonFileLikeFileHandler()
{
    VSIFileManager::InstallHandler( "/vsipythonfilelike/", new VSIPythonFileLikeFilesystemHandler );
    std::cout << "Install handler\n" << std::flush;
}

VSIPythonFileLikeFilesystemHandler::~VSIPythonFileLikeFilesystemHandler()
{
    for( const auto &iter : oFileList )
    {
//        CPLAtomicDec(&iter.second->nRefCount);
        delete iter.second;
    }

    if( hMutex != nullptr )
        CPLDestroyMutex( hMutex );
    hMutex = nullptr;
}

std::string VSIPythonFileLikeFilesystemHandler::NormalizePath( const std::string &in )
{
    std::cout << "Normalize path\n" << std::flush;
    CPLString s(in);
    std::replace(s.begin(), s.end(), '\\', '/');
    s.replaceAll("//", '/');
    if( !s.empty() && s.back() == '/' )
        s.resize(s.size() - 1);
    return std::move(s);
}

VSIVirtualHandle *VSIPythonFileLikeFilesystemHandler::Open( const char *pszFilename,
                               const char *pszAccess,
                               bool bSetError)
                               // CSLConstList papszOptions )
{
    std::cout << "Open\n" << std::flush;
    CPLMutexHolder oHolder( &hMutex );
    const CPLString osFilename = NormalizePath(pszFilename);
    if( osFilename.empty() ) {
        std::cout << "Open: Filename is empty\n" << std::flush;
        return nullptr;
    }

/* -------------------------------------------------------------------- */
/*      Get the filename we are opening, create if needed.              */
/* -------------------------------------------------------------------- */
    PythonVSIVirtualHandle *poFile = nullptr;
    if( oFileList.find(osFilename) != oFileList.end() )
        poFile = oFileList[osFilename];

    // If no file and opening in read, error out.
    if( strstr(pszAccess, "w") == nullptr
        && strstr(pszAccess, "a") == nullptr
        && poFile == nullptr )
    {
        std::cout << "Open: No such file or directory\n" << std::flush;
        if( bSetError )
        {
            VSIError(VSIE_FileError, "No such file or directory");
        }
        errno = ENOENT;
        return nullptr;
    }

    // Create.
    if( poFile == nullptr || strstr(pszAccess, "r") == nullptr)
    {
        if( bSetError )
        {
            VSIError(VSIE_FileError, "File system does not support creation via 'Open'.");
        }
        errno = ENOENT;
        std::cout << "Open: Creation not allowed\n" << std::flush;
        return nullptr;
    }

    if (poFile->open_file_obj == nullptr) {
        std::cout << "Open: Open file pointer is null\n" << std::flush;
        return nullptr;
    }

//    if( poFile->bIsDirectory )
//    {
//        errno = EISDIR;
//        return nullptr;
//    }
    std::cout << "Open: Success\n" << std::flush;
    return reinterpret_cast<VSIVirtualHandle *>( poFile );
}


int VSIPythonFileLikeFilesystemHandler::Stat(const char *pszFilename, VSIStatBufL *pStatBuf, int nFlags) {
    std::cout << "Stat\n" << std::flush;
    CPLMutexHolder oHolder( &hMutex );

    const CPLString osFilename = NormalizePath(pszFilename);

    memset( pStatBuf, 0, sizeof(VSIStatBufL) );

    if( osFilename == "/vsipythonfilelike" || osFilename == "/vsipythonfilelike/" )
    {
        pStatBuf->st_size = 0;
        pStatBuf->st_mode = S_IFDIR;
        std::cout << "Stat: is dir\n" << std::flush;
        return 0;
    }

    std::cout << "osFilename: " << osFilename << "\n" << std::flush;
    if( oFileList.find(osFilename) == oFileList.end() )
    {
        errno = ENOENT;
        std::cout << "Stat: Not found\n" << std::flush;
        return -1;
    }

    PythonVSIVirtualHandle *poFile = oFileList[osFilename];

    memset( pStatBuf, 0, sizeof(VSIStatBufL) );

//    if( poFile->bIsDirectory )
//    {
//        pStatBuf->st_size = 0;
//        pStatBuf->st_mode = S_IFDIR;
//    }
//    else
//    {
    // TODO: Get length from python object
    // TODO: Get modification time from ?
    pStatBuf->st_size = 20578188; //poFile->nLength;
    pStatBuf->st_mode = S_IFREG;
    pStatBuf->st_mtime = 0; //poFile->mTime;
//    }

    std::cout << "Stat: Success\n" << std::flush;
    return 0;
}
int VSIPythonFileLikeFilesystemHandler::Mkdir( const char *pszDirname, long nMode ) {
    std::cout << "Mkdir\n" << std::flush;
    return 0;
}
int VSIPythonFileLikeFilesystemHandler::Rmdir( const char *pszDirname ) {
    std::cout << "Rmdir\n" << std::flush;
    return 0;
}
char **VSIPythonFileLikeFilesystemHandler::ReadDirEx( const char *pszDirname, int nMaxFiles ) {
    std::cout << "ReadDirEx : " << pszDirname << " : " << nMaxFiles << "\n" << std::flush;
    CPLMutexHolder oHolder( &hMutex );

    const CPLString osPath = NormalizePath(pszDirname);

    char **papszDir = nullptr;
    size_t nPathLen = osPath.size();

    if( nPathLen > 0 && osPath.back() == '/' )
        nPathLen--;

    // In case of really big number of files in the directory, CSLAddString
    // can be slow (see #2158). We then directly build the list.
    int nItems = 0;
    int nAllocatedItems = 0;

    PyGILState_STATE gil_state = PyGILState_Ensure();
    for( const auto& iter : oFileList )
    {
        std::cout << "ReadDirEx just before pszFilePath\n" << std::flush;
        PyObject *path_attr = PyObject_GetAttrString(iter.second->open_file_obj, "_path");
        const char *pszFilePath = PyBytes_AsString(path_attr);
        std::cout << "ReadDirEx pszFilePath: " << pszFilePath << "\n" << std::flush;
        if( EQUALN(osPath, pszFilePath, nPathLen)
            && pszFilePath[nPathLen] == '/'
            && strstr(pszFilePath+nPathLen+1, "/") == nullptr )
        {
            if( nItems == 0 )
            {
                papszDir = static_cast<char**>(CPLCalloc(2, sizeof(char*)));
                nAllocatedItems = 1;
            }
            else if( nItems >= nAllocatedItems )
            {
                nAllocatedItems = nAllocatedItems * 2;
                papszDir = static_cast<char**>(
                    CPLRealloc(papszDir, (nAllocatedItems + 2)*sizeof(char*)) );
            }

            papszDir[nItems] = CPLStrdup(pszFilePath+nPathLen+1);
            Py_DECREF(path_attr);
            papszDir[nItems+1] = nullptr;

            nItems++;
            if( nMaxFiles > 0 && nItems > nMaxFiles )
                break;
        }
        else {
            Py_DECREF(path_attr);
        }
    }

    PyGILState_Release(gil_state);
    std::cout << "ReadDirEx first entry: " << papszDir[0] << ": " << nItems << "\n" << std::flush;
    return papszDir;
}
int VSIPythonFileLikeFilesystemHandler::Rename( const char *oldpath, const char *newpath ) {
    std::cout << "Rename\n" << std::flush;
    return 0;
}
GIntBig VSIPythonFileLikeFilesystemHandler::GetDiskFreeSpace( const char* pszDirname ) { return 0; }

/************************************************************************/
/*                               Unlink()                               */
/************************************************************************/

int VSIPythonFileLikeFilesystemHandler::Unlink( const char * pszFilename )
{
    std::cout << "Unlink\n" << std::flush;
    CPLMutexHolder oHolder( &hMutex );
    return Unlink_unlocked(pszFilename);
}

/************************************************************************/
/*                           Unlink_unlocked()                          */
/************************************************************************/

int VSIPythonFileLikeFilesystemHandler::Unlink_unlocked( const char * pszFilename )
{
    const CPLString osFilename = NormalizePath(pszFilename);

    if( oFileList.find(osFilename) == oFileList.end() )
    {
        errno = ENOENT;
        return -1;
    }

//    PythonVSIVirtualHandle *poFile = oFileList[osFilename];
    oFileList.erase( oFileList.find(osFilename) );

    return 0;
}


VSILFILE *CreatePyVSIInMem(const char *pszFilename, PythonVSIVirtualHandle *handle) {
    if( VSIFileManager::GetHandler("")
        == VSIFileManager::GetHandler("/vsipythonfilelike/") )
        VSIInstallPythonFileLikeFileHandler();

    VSIPythonFileLikeFilesystemHandler *poHandler =
        static_cast<VSIPythonFileLikeFilesystemHandler *>(
                VSIFileManager::GetHandler("/vsipythonfilelike/"));

    if( pszFilename == nullptr ) {
        std::cout << "pszFilename is null\n" << std::flush;
        return nullptr;
    }

    const CPLString osFilename =
        VSIPythonFileLikeFilesystemHandler::NormalizePath(pszFilename);
    if( osFilename.empty() ) {
        std::cout << "osFilename is null\n" << std::flush;
        return nullptr;
    }

//    VSIMemFile *poFile = new VSIMemFile;
//
//    poFile->osFilename = osFilename;
//    poFile->bOwnData = CPL_TO_BOOL(bTakeOwnership);
//    poFile->pabyData = pabyData;
//    poFile->nLength = nDataLength;
//    poFile->nAllocLength = nDataLength;

//    {
//        CPLMutexHolder oHolder( &poHandler->hMutex );
//        poHandler->Unlink_unlocked(osFilename);
        poHandler->oFileList[osFilename] = handle;// poFile;
//        CPLAtomicInc(&(poFile->nRefCount));
//#ifdef DEBUG_VERBOSE
//        CPLDebug("VSIMEM", "VSIFileFromMemBuffer() %s: ref_count=%d (after)",
//                 poFile->osFilename.c_str(), poFile->nRefCount);
//#endif
//    }

    // TODO(schwehr): Fix this so that the using statement is not needed.
    // Will just adding the bool for bSetError be okay?
    std::cout << "Add handle osFilename: " << osFilename << "\n" << std::flush;
    return reinterpret_cast<VSILFILE *>( handle );
//    return reinterpret_cast<VSILFILE *>( poHandler->Open( osFilename, "r+" ) );

}

} /* namespace pyvsi_handle */
